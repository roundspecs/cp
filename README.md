# Advices
- Don't rush
- DP: ready goes with dp
- BITMASK: x = a ^ b ^ x
- GRAPH: use vis
- DFS: use at, nxt
- STYLE: use {} even for 1 line
- EXIT: exit(0);

# Learning resources
- [ ] [Sorting](/resources/sorting.md)
- [ ] [Binary Search](/resources/binary_search.md)

# CSES Progress
- [x] 1 Introduction
  - [x] 1.1.2 Tips for Practicing
- [ ] 2 Programming Techniques
  - [x] 2.1 Language Features
    - [x] 2.1.1 Input and Output
    - [ ] 2.1.2 Working with Numbers
    - [x] 2.1.3 Shortening Code
  - [x] 2.2 Recursive Algorithms
    - [x] 2.2.1 Generating Subsets
    - [x] 2.2.2 Generating Permutations
    - [x] 2.2.3 Backtracking
  - [ ] 2.3 Bit Manipulation
    - [x] 2.3.1 Bit Operations
    - [ ] 2.3.2 Representing Sets
- [ ] 3 Efﬁciency
  - [ ] 3.1 Time Complexity
    - [x] 3.1.1 Calculation Rules
    - [x] 3.1.2 Common Time Complexities
    - [x] 3.1.3 Estimating Efﬁciency
    - [ ] 3.1.4 Formal Deﬁnitions
  - [ ] 3.2 Algorithm Design Examples
    - [x] 3.2.1 Maximum Subarray Sum
    - [ ] 3.2.2 Two Queens Problem
- [ ] 4 Sorting and Searching
  - [ ] 4.1 Sorting Algorithms
    - [x] 4.1.1 Bubble Sort
    - [x] 4.1.2 Merge Sort
    - [ ] 4.1.3 Sorting Lower Bound
    - [ ] 4.1.4 Counting Sort
    - [ ] 4.1.5 Sorting in Practice
  - [ ] 4.2 Solving Problems by Sorting
    - [ ] 4.2.1 Sweep Line Algorithms
    - [ ] 4.2.2 Scheduling Events
    - [ ] 4.2.3 Tasks and Deadlines
  - [ ] 4.3 Binary Search
    - [ ] 4.3.1 Implementing the Search
    - [ ] 4.3.2 Finding Optimal Solutions

# PAPS Progress
- [ ] 3 The C++ Standard Library
  - [x] 3.1 vector
    - [x] 3.1.1 Iterators
  - [x] 3.2 queue
  - [x] 3.3 stack
  - [ ] 3.4 priority_queue
  - [x] 3.5 set and map
  - [x] 3.6 Math
  - [x] 3.7 Algorithms
    - [x] 3.7.1 Sorting
    - [x] 3.7.2 Searching
    - [x] 3.7.3 Permutations
  - [x] 3.8 Strings
    - [x] 3.8.1 Conversions
  - [ ] 3.9 Input/Output
    - [ ] 3.9.1 Detecting End of File
    - [ ] 3.9.2 Input Line by Line
    - [ ] 3.9.3 Output Decimal Precision
  - [ ] 3.10 Additional Exercises

- [ ] 5 Time Complexity
  - [x] 5.1 The Complexity of Insertion Sort
  - [x] 5.2 Asymptotic Notation
  - [ ] 5.2.1 Amortized Complexity
  - [x] 5.3 NP-complete problems
  - [ ] 5.4 Other Types of Complexities
  - [ ] 5.5 The Importance of Constant Factors
  - [ ] 5.6 Additional Exercises
  - [ ] 5.7 Chapter Notes

- [ ] 6 Foundational Data Structures
  - [x] 6.1 Dynamic Arrays 103
  - [x] 6.2 Stacks 109
  - [x] 6.3 Queues 109
  - [ ] 6.4 Graphs 111
  - [ ] 6.4.1 Adjacency Matrices 111
  - [ ] 6.4.2 Adjacency Lists 113
  - [ ] 6.4.3 Adjacency Maps 113
  - [ ] 6.5 Priority Queues 114
  - [ ] 6.5.1 Binary Trees 115
  - [ ] 6.5.2 Heaps 116
  - [ ] 6.6 Chapter Notes 120

- [ ] 7 Brute Force
  - [ ] 7.1 Optimization Problems 123
  - [ ] 7.2 Generate and Test 124
  - [ ] 7.3 Backtracking 128
  - [ ] 7.4 Fixing Parameters 135
  - [ ] 7.5 Meet in the Middle 138
  - [ ] 7.6 Chapter Notes 140

- [ ] 8 Greedy Algorithms
  - [ ] 8.1 Optimal Substructure 141
  - [ ] 8.2 Locally Optimal Choices 143
  - [ ] 8.3 Scheduling 145
  - [ ] 8.4 Chapter Notes 148

- [ ] A Discrete Mathematics
  - [x] A.1 Logic
  - [x] A.2 Sets and Sequences
  - [x] A.3 Sums and Products
  - [x] A.4 Graphs
  - [ ] A.5 Chapter Notes

# CLRS Progress
- [ ] I Foundations
  - [x] 1 The Role of Algorithms in Computing
    - [x] 1.1 Algorithms
    - [x] 1.2 Algorithms as a technology
  - [ ] 2 Getting Started
    - [x] 2.1 Insertion sort
    - [x] 2.2 Analyzing algorithms
    - [ ] 2.3 Designing algorithms
  - [ ] 3 Characterizing Running Times
    - [ ] 3.1 O-notation, Ω-notation, and Θ-notation
    - [ ] 3.2 Asymptotic notation: formal deﬁnitions
    - [ ] 3.3 Standard notations and common functions
  - [ ] 4 Divide-and-Conquer
    - [ ] 4.1 Multiplying square matrices
    - [ ] 4.2 Strassen’s algorithm for matrix multiplication
    - [ ] 4.3 The substitution method for solving recurrences
    - [ ] 4.4 The recursion-tree method for solving recurrences
    - [ ] 4.5 The master method for solving recurrences