{
    "Ordered Set": {
        "prefix": "oset",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int, null_type, greater<int>, rb_tree_tag, tree_order_statistics_node_update> oset;"
        ],
        "description": "Ordered Set"
    },
    "Binary Exponentiation": {
        "prefix": "pow_mod",
        "body": [
            "long long pow_mod(long long a, long long b, long long m) {",
            "    a %= m;",
            "    long long res = 1;",
            "    while (b > 0) {",
            "        if (b & 1)",
            "            res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Next Comp with Monotonic Stack": {
        "prefix": "next comp",
        "body": [
            "template <typename T>",
            "vector<int> nextComp(vector<T> v, function<bool(T, T)> comp) {",
            "    int n = v.size();",
            "    stack<int> pending;",
            "    vector<int> ans(n);",
            "    // for (int i = n-1; i >= 0; i--) // prev",
            "    for (int i = 0; i < n; i++) {",
            "        while (!pending.empty() && comp(v[i], v[pending.top()])) {",
            "            ans[pending.top()] = i;",
            "            pending.pop();",
            "        }",
            "        pending.push(i);",
            "    }",
            "    while (!pending.empty()) {",
            "        ans[pending.top()] = n; // -1; // prev",
            "        pending.pop();",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Next Comp with Monotonic Stack"
    },
    "Segment Tree": {
        "prefix": "segtree",
        "body": [
            "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
            "    int size, height, _n;",
            "    vector<S> d;",
            "",
            "    segtree() : segtree(0){};",
            "    segtree(int n) : segtree(vector<S>(n, e())){};",
            "    segtree(const vector<S> &v) {",
            "        _n = v.size();",
            "        size = 1;",
            "        height = 0;",
            "        while (size < _n)",
            "            size *= 2, height++;",
            "        d.resize(2 * size, e());",
            "        for (int i = 0; i < _n; i++)",
            "            d[i + size] = v[i];",
            "        for (int i = size - 1; i > 0; i--)",
            "            update(i);",
            "    }",
            "",
            "    void set(int i, S val) {",
            "        assert(0 <= i && i < _n);",
            "        i += size;",
            "        d[i] = val;",
            "        i /= 2;",
            "        while (i > 0) {",
            "            update(i);",
            "            i /= 2;",
            "        }",
            "    }",
            "",
            "    S get(int i) {",
            "        assert(0 <= i && i < _n);",
            "        return d[i + size];",
            "    }",
            "",
            "    S prod(int l, int r, int x, int lx, int rx) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        if (r <= lx || rx <= l)",
            "            return e();",
            "        if (l <= lx && rx <= r)",
            "            return d[x];",
            "        int mx = lx + (rx - lx) / 2;",
            "        return op(prod(l, r, 2 * x, lx, mx), prod(l, r, 2 * x + 1, mx, rx));",
            "    }",
            "",
            "    S prod(int l, int r) {",
            "        return prod(l, r, 1, 0, size);",
            "    }",
            "",
            "    S all_prod() {",
            "        return d[1];",
            "    }",
            "",
            "    void update(int idx) {",
            "        d[idx] = op(d[2 * idx], d[2 * idx + 1]);",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    }
}