{
    "Ordered Set": {
        "prefix": "oset",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int, null_type, greater<int>, rb_tree_tag, tree_order_statistics_node_update> oset;"
        ],
        "description": "Ordered Set"
    },
    "Binary Exponentiation": {
        "prefix": "pow_mod",
        "body": [
            "long long pow_mod(long long a, long long b, long long m) {",
            "    a %= m;",
            "    long long res = 1;",
            "    while (b > 0) {",
            "        if (b & 1)",
            "            res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Next Comp with Monotonic Stack": {
        "prefix": "next comp",
        "body": [
            "template <typename T>",
            "vector<int> nextComp(vector<T> v, function<bool(T, T)> comp) {",
            "    int n = v.size();",
            "    stack<int> pending;",
            "    vector<int> ans(n);",
            "    // for (int i = n-1; i >= 0; i--) // prev",
            "    for (int i = 0; i < n; i++) {",
            "        while (!pending.empty() && comp(v[i], v[pending.top()])) {",
            "            ans[pending.top()] = i;",
            "            pending.pop();",
            "        }",
            "        pending.push(i);",
            "    }",
            "    while (!pending.empty()) {",
            "        ans[pending.top()] = n; // -1; // prev",
            "        pending.pop();",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Next Comp with Monotonic Stack"
    },
    "Segment Tree": {
        "prefix": "segtree",
        "body": [
            "template<class S, S (*op)(S, S), S (*e)()>",
            "struct segtree {",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "    void update(int k) {",
            "        d[k] = op(d[2 * k], d[2 * k + 1]);",
            "    }",
            "    segtree() : segtree(0){};",
            "    segtree(int n) : segtree(std::vector<S>(n, e())){};",
            "    segtree(vector<S> &v) {",
            "        _n = v.size();",
            "        size = 1;",
            "        log = 0;",
            "        while (size < _n) size *= 2, log++;",
            "        d.resize(2 * size, e());",
            "        for (int i = 0; i < _n; i++) d[i + size] = v[i];",
            "        for (int i = size - 1; i > 0; i--) update(i);",
            "    }",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "    S get(int p) {",
            "        assert(0 <= p && p < _n);",
            "        return d[p + size];",
            "    }",
            "    S prod(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        S sml = e(), smr = e();",
            "        l += size;",
            "        r += size;",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(sml, smr);",
            "    }",
            "    S all_prod() {",
            "        return d[1];",
            "    }",
            "    template<bool (*f)(S)>",
            "    int max_right(int l) {",
            "        return max_right(l, [](S x) { return f(x); });",
            "    }",
            "    template<class F>",
            "    int max_right(int l, F f) {",
            "        assert(0 <= l && l <= _n);",
            "        assert(f(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!f(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    l = (2 * l);",
            "                    if (f(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "    template<bool (*f)(S)>",
            "    int min_left(int r) {",
            "        return min_left(r, [](S x) { return f(x); });",
            "    }",
            "    template<class F>",
            "    int min_left(int r, F f) {",
            "        assert(0 <= r && r <= _n);",
            "        assert(f(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!f(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    r = (2 * r + 1);",
            "                    if (f(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    }
}